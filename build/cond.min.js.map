{"version":3,"file":"cond.min.js","sources":["webpack/universalModuleDefinition","cond.min.js","webpack/bootstrap cbf2472a30cee7ffad45*","./src/index.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","signal","cond","arguments","length","_signal","restartCase","apply","concat","slice","HANDLERS","forEach","handlerEntry","handlerBind","handledBody","handlers","oldHandlers","handlerCase","sentinel","map","e","handler","error","restartableBody","oldRestarts","RESTARTS","restarts","entry","name","description","callback","args","restart","_restart","Array","isArray","findRestart","restartArgs","i","undefined","debug","condition","__chosenRestart","__restartArgs","Error"],"mappings":"CAAA,SAAAA,EAAAC,GACA,gBAAAC,UAAA,gBAAAC,QACAA,OAAAD,QAAAD,IACA,kBAAAG,gBAAAC,IACAD,OAAAH,GACA,gBAAAC,SACAA,QAAA,KAAAD,IAEAD,EAAA,KAAAC,KACCK,KAAA,WACD,MCAgB,UAAUC,GCL1B,QAAAC,GAAAC,GAEA,GAAAC,EAAAD,GACA,MAAAC,GAAAD,GAAAP,OAGA,IAAAC,GAAAO,EAAAD,IACAP,WACAS,GAAAF,EACAG,QAAA,EAUA,OANAL,GAAAE,GAAAI,KAAAV,EAAAD,QAAAC,IAAAD,QAAAM,GAGAL,EAAAS,QAAA,EAGAT,EAAAD,QAtBA,GAAAQ,KAqCA,OAVAF,GAAAM,EAAAP,EAGAC,EAAAO,EAAAL,EAGAF,EAAAQ,EAAA,GAIAR,EAAA,KDgBM,SAASL,GEvDf,YAEA,SAAAc,GAAAC,GACA,MAAAC,WAAAC,QAAA,EACAC,EAAAH,GAEAI,EAAAC,MACAjB,MACA,WAAkB,MAAAe,GAAAH,KAAsBM,UAAAC,MAAAZ,KAAAM,UAAA,KAIxC,QAAAE,GAAAH,GACAQ,EAAAC,QAAA,SAAAC,GACAV,YAAAU,GAAA,IACAA,EAAA,GAAAV,KAKA,QAAAW,GAAAC,GACA,GAAAC,MAAAN,MAAAZ,KAAAM,UAAA,GACAa,EAAAN,CACA,KAEA,MADAA,GAAAK,EAAAP,OAAAE,GACAI,EAAAjB,KAAAP,MACG,QACHoB,EAAAM,GAIA,QAAAC,GAAAH,GACA,GAAAI,MACAH,KAAAN,MAAAZ,KAAAM,UAAA,GAAAgB,IAAA,SAAAP,GACA,OAAAA,EAAA,YAAAQ,GAGA,KAFAF,GAAAG,QAAAT,EAAA,GACAM,EAAAI,MAAAF,EACAF,KAGA,KACA,MAAAL,GAAAN,MAAAjB,MAAAwB,GAAAN,OAAAO,IACG,MAAAK,GACH,GAAAA,IAAAF,EACA,MAAAA,GAAAG,QAAAxB,KAAAP,KAAA4B,EAAAI,MAEA,MAAAF,IAaA,QAAAd,GAAAiB,GACA,GAAAL,MACAM,EAAAC,EACAC,KAAAjB,MAAAZ,KAAAM,UAAA,GAAAgB,IAAA,SAAAQ,GACA,GAAAC,GAAAD,EAAA,GACAE,EAAA,gBAAAF,GAAA,GAAAA,EAAA,MACAG,EAAAD,EAAAF,EAAA,GAAAA,EAAA,EACA,QAAAC,EAAAC,EAAA,WAGA,KAFAX,GAAAY,WACAZ,EAAAa,KAAA5B,UACAe,KAGA,KAEA,MADAO,GAAAC,EAAAlB,OAAAiB,GACAF,EAAA1B,KAAAP,MACG,MAAA8B,GACH,GAAAA,IAAAF,EACA,MAAAA,GAAAY,SAAAvB,MAAAjB,KAAA4B,EAAAa,KAEA,MAAAX,GAEG,QACHK,EAAAD,GAIA,QAAAQ,GAAAJ,GACA,MAAAK,GAAAL,GAEA,QAAAK,GAAAL,GACA,GAAAI,GAAAE,MAAAC,QAAAP,KAAAQ,EAAAR,GACAS,KAAA5B,MAAAZ,KAAAM,UAAA,EACA6B,KAAA5B,OAAA,GAAAG,MAAAjB,KAAA+C,GAGA,QAAAD,GAAAR,GACA,mBAAAA,GAQA,MAAAH,GAAAG,EAPA,QAAAU,GAAA,EAAmBA,EAAAb,EAAArB,OAAqBkC,IACxC,MAAAV,KAAAH,EAAAa,GAAA,GACAb,EAAAa,GAEAC,OAUA,QAAAC,GAAAC,GAcA,GAAAC,GACAC,CAqBA,UAAAD,EAGA,KAAAD,EAFAR,GAAA1B,MAAAjB,KAAAqD,GAkBA,GAAAjC,KAEAkC,MAAAJ,IAEAf,IAGAtC,GAAAD,SACAe,SACAY,cACAI,cACAX,cACA0B,UACAI,cACAI","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"cond\"] = factory();\n\telse\n\t\troot[\"cond\"] = factory();\n})(this, function() {\nreturn ","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"cond\"] = factory();\n\telse\n\t\troot[\"cond\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/ \t\t\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/ \t\t\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/ \t\t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/******/ \t\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/ \t\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/ \t\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/ \t\n/******/ \t\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tfunction signal(cond) {\n\t  if (arguments.length <= 1) {\n\t    return _signal(cond);\n\t  } else {\n\t    return restartCase.apply(\n\t      this,\n\t      [function(){return _signal(cond);}].concat([].slice.call(arguments, 1)));\n\t  }\n\t}\n\t\n\tfunction _signal(cond) {\n\t  HANDLERS.forEach(function(handlerEntry) {\n\t    if (cond instanceof handlerEntry[0]) {\n\t      handlerEntry[1](cond);\n\t    }\n\t  });\n\t}\n\t\n\tfunction handlerBind(handledBody) {\n\t  var handlers = [].slice.call(arguments, 1),\n\t      oldHandlers = HANDLERS;\n\t  try {\n\t    HANDLERS = handlers.concat(HANDLERS);\n\t    return handledBody.call(this);\n\t  } finally {\n\t    HANDLERS = oldHandlers;\n\t  }\n\t}\n\t\n\tfunction handlerCase(handledBody) {\n\t  var sentinel = {},\n\t      handlers = [].slice.call(arguments, 1).map(function(handlerEntry) {\n\t        return [handlerEntry[0], function(e) {\n\t          sentinel.handler = handlerEntry[1];\n\t          sentinel.error = e;\n\t          throw sentinel;\n\t        }];\n\t      });\n\t  try {\n\t    return handlerBind.apply(this, [handledBody].concat(handlers));\n\t  } catch (e) {\n\t    if (e === sentinel) {\n\t      return sentinel.handler.call(this, sentinel.error);\n\t    } else {\n\t      throw e;\n\t    }\n\t  }\n\t}\n\t\n\tfunction listRestarts() {\n\t  // \"Deep enough\" copy to protect the internal RESTARTS array structure from\n\t  // user shenanigans.\n\t  return RESTARTS.map(function(x) {\n\t    return x.map(function(x) { return x; });\n\t  });\n\t}\n\t\n\tfunction restartCase(restartableBody) {\n\t  var sentinel = {},\n\t      oldRestarts = RESTARTS,\n\t      restarts = [].slice.call(arguments, 1).map(function(entry) {\n\t        var name = entry[0],\n\t            description = typeof entry[1] === \"string\" ? entry[1] : \"\",\n\t            callback = description ? entry[2] : entry[1];\n\t        return [name, description, function() {\n\t          sentinel.callback = callback;\n\t          sentinel.args = arguments;\n\t          throw sentinel;\n\t        }];\n\t      });\n\t  try {\n\t    RESTARTS = restarts.concat(RESTARTS);\n\t    return restartableBody.call(this);\n\t  } catch(e) {\n\t    if (e === sentinel) {\n\t      return sentinel.callback.apply(this, sentinel.args);\n\t    } else {\n\t      throw e;\n\t    }\n\t  } finally {\n\t    RESTARTS = oldRestarts;\n\t  }\n\t}\n\t\n\tfunction restart(name) {\n\t  return _restart(name);\n\t}\n\tfunction _restart(name) {\n\t  var restart = Array.isArray(name) ? name : findRestart(name),\n\t      restartArgs = [].slice.call(arguments, 1);\n\t  restart[restart.length-1].apply(this, restartArgs);\n\t}\n\t\n\tfunction findRestart(name) {\n\t  if (typeof name === \"string\") {\n\t    for (var i = 0; i < RESTARTS.length; i++) {\n\t      if (name === RESTARTS[i][0]) {\n\t        return RESTARTS[i];\n\t      }\n\t      return undefined;\n\t    }\n\t  } else {\n\t    return RESTARTS[name];\n\t  }\n\t}\n\t\n\t/**\n\t * Invokes the configured debugger.\n\t */\n\tfunction debug(condition) {\n\t  /*****************************************************************/\n\t  /* Welcome to the */ debugger; /* Read below for instructions!!! */\n\t  /*                                                               */\n\t  /* Restarts may be available.                                    */\n\t  /* Call showRestarts() in the JS console to list them.           */\n\t  /*                                                               */\n\t  /* If you pick a restart, it will be invoked after you unpause   */\n\t  /* the debugger. Otherwise, `condition` will be thrown.          */\n\t  /*                                                               */\n\t  /*                Thanks for using CondJS!                       */\n\t  /*                                                               */\n\t  /*****************************************************************/\n\t  \n\t  var __chosenRestart,\n\t      __restartArgs;\n\t  function restart(name) {\n\t    __chosenRestart = name;\n\t    __restartArgs = arguments;\n\t    console.log(\"You have chosen restart: \", name);\n\t    console.log(\"Unpause the debugger to continue.\");\n\t  }\n\t  function showRestarts() {\n\t    console.log(\n\t      (((condition && condition.toString) ? condition.toString() + \"\\n\": \"\") +\n\t       \"Available restarts: \\n\" +\n\t       \"\\n\" +\n\t       RESTARTS.reduce(function(acc, entry, i) {\n\t         return acc + formatRestart(entry, i) + \"\\n\";\n\t       }, \"\") + \"\\n\" +\n\t       \"To use a restart, use `restart(<name or index>[, arg1[, arg2 ...]])`\\n\"+\n\t       \"\\n\" +\n\t       \"Unpause your debugger to continue.\" +\n\t       \"\"));\n\t  }\n\t\n\t  if (__chosenRestart != null) {\n\t    _restart.apply(this, __restartArgs);\n\t  } else {\n\t    throw condition;\n\t  }\n\t}\n\t\n\tfunction formatRestart(entry, i) {\n\t  var name = entry[0],\n\t      description = (typeof entry[1] === \"string\" && entry[1].length) ?\n\t        \": \"+entry[1] :\n\t        \"\";\n\t  return \"[\"+i+\"] \"+entry[0]+description;\n\t}\n\t\n\t/*\n\t * Internals\n\t */\n\t\n\tvar HANDLERS = [[\n\t  // If we get an error, force falling back into the debugger.\n\t  Error, debug\n\t]],\n\t    RESTARTS = [];\n\t\n\t\n\tmodule.exports = {\n\t  signal: signal,\n\t  handlerBind: handlerBind,\n\t  handlerCase: handlerCase,\n\t  restartCase: restartCase,\n\t  restart: restart,\n\t  findRestart: findRestart,\n\t  debug: debug\n\t};\n\n\n/***/ }\n/******/ ])\n})\n","\n// The module cache\nvar installedModules = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tif(installedModules[moduleId])\n\t\treturn installedModules[moduleId].exports;\n\t\n\t// Create a new module (and put it into the cache)\n\tvar module = installedModules[moduleId] = {\n\t\texports: {},\n\t\tid: moduleId,\n\t\tloaded: false\n\t};\n\t\n\t// Execute the module function\n\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\t\n\t// Flag the module as loaded\n\tmodule.loaded = true;\n\t\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = modules;\n\n// expose the module cache\n__webpack_require__.c = installedModules;\n\n// __webpack_public_path__\n__webpack_require__.p = \"\";\n\n\n// Load entry module and return exports\nreturn __webpack_require__(0);","\"use strict\";\n\nfunction signal(cond) {\n  if (arguments.length <= 1) {\n    return _signal(cond);\n  } else {\n    return restartCase.apply(\n      this,\n      [function(){return _signal(cond);}].concat([].slice.call(arguments, 1)));\n  }\n}\n\nfunction _signal(cond) {\n  HANDLERS.forEach(function(handlerEntry) {\n    if (cond instanceof handlerEntry[0]) {\n      handlerEntry[1](cond);\n    }\n  });\n}\n\nfunction handlerBind(handledBody) {\n  var handlers = [].slice.call(arguments, 1),\n      oldHandlers = HANDLERS;\n  try {\n    HANDLERS = handlers.concat(HANDLERS);\n    return handledBody.call(this);\n  } finally {\n    HANDLERS = oldHandlers;\n  }\n}\n\nfunction handlerCase(handledBody) {\n  var sentinel = {},\n      handlers = [].slice.call(arguments, 1).map(function(handlerEntry) {\n        return [handlerEntry[0], function(e) {\n          sentinel.handler = handlerEntry[1];\n          sentinel.error = e;\n          throw sentinel;\n        }];\n      });\n  try {\n    return handlerBind.apply(this, [handledBody].concat(handlers));\n  } catch (e) {\n    if (e === sentinel) {\n      return sentinel.handler.call(this, sentinel.error);\n    } else {\n      throw e;\n    }\n  }\n}\n\nfunction listRestarts() {\n  // \"Deep enough\" copy to protect the internal RESTARTS array structure from\n  // user shenanigans.\n  return RESTARTS.map(function(x) {\n    return x.map(function(x) { return x; });\n  });\n}\n\nfunction restartCase(restartableBody) {\n  var sentinel = {},\n      oldRestarts = RESTARTS,\n      restarts = [].slice.call(arguments, 1).map(function(entry) {\n        var name = entry[0],\n            description = typeof entry[1] === \"string\" ? entry[1] : \"\",\n            callback = description ? entry[2] : entry[1];\n        return [name, description, function() {\n          sentinel.callback = callback;\n          sentinel.args = arguments;\n          throw sentinel;\n        }];\n      });\n  try {\n    RESTARTS = restarts.concat(RESTARTS);\n    return restartableBody.call(this);\n  } catch(e) {\n    if (e === sentinel) {\n      return sentinel.callback.apply(this, sentinel.args);\n    } else {\n      throw e;\n    }\n  } finally {\n    RESTARTS = oldRestarts;\n  }\n}\n\nfunction restart(name) {\n  return _restart(name);\n}\nfunction _restart(name) {\n  var restart = Array.isArray(name) ? name : findRestart(name),\n      restartArgs = [].slice.call(arguments, 1);\n  restart[restart.length-1].apply(this, restartArgs);\n}\n\nfunction findRestart(name) {\n  if (typeof name === \"string\") {\n    for (var i = 0; i < RESTARTS.length; i++) {\n      if (name === RESTARTS[i][0]) {\n        return RESTARTS[i];\n      }\n      return undefined;\n    }\n  } else {\n    return RESTARTS[name];\n  }\n}\n\n/**\n * Invokes the configured debugger.\n */\nfunction debug(condition) {\n  /*****************************************************************/\n  /* Welcome to the */ debugger; /* Read below for instructions!!! */\n  /*                                                               */\n  /* Restarts may be available.                                    */\n  /* Call showRestarts() in the JS console to list them.           */\n  /*                                                               */\n  /* If you pick a restart, it will be invoked after you unpause   */\n  /* the debugger. Otherwise, `condition` will be thrown.          */\n  /*                                                               */\n  /*                Thanks for using CondJS!                       */\n  /*                                                               */\n  /*****************************************************************/\n  \n  var __chosenRestart,\n      __restartArgs;\n  function restart(name) {\n    __chosenRestart = name;\n    __restartArgs = arguments;\n    console.log(\"You have chosen restart: \", name);\n    console.log(\"Unpause the debugger to continue.\");\n  }\n  function showRestarts() {\n    console.log(\n      (((condition && condition.toString) ? condition.toString() + \"\\n\": \"\") +\n       \"Available restarts: \\n\" +\n       \"\\n\" +\n       RESTARTS.reduce(function(acc, entry, i) {\n         return acc + formatRestart(entry, i) + \"\\n\";\n       }, \"\") + \"\\n\" +\n       \"To use a restart, use `restart(<name or index>[, arg1[, arg2 ...]])`\\n\"+\n       \"\\n\" +\n       \"Unpause your debugger to continue.\" +\n       \"\"));\n  }\n\n  if (__chosenRestart != null) {\n    _restart.apply(this, __restartArgs);\n  } else {\n    throw condition;\n  }\n}\n\nfunction formatRestart(entry, i) {\n  var name = entry[0],\n      description = (typeof entry[1] === \"string\" && entry[1].length) ?\n        \": \"+entry[1] :\n        \"\";\n  return \"[\"+i+\"] \"+entry[0]+description;\n}\n\n/*\n * Internals\n */\n\nvar HANDLERS = [[\n  // If we get an error, force falling back into the debugger.\n  Error, debug\n]],\n    RESTARTS = [];\n\n\nmodule.exports = {\n  signal: signal,\n  handlerBind: handlerBind,\n  handlerCase: handlerCase,\n  restartCase: restartCase,\n  restart: restart,\n  findRestart: findRestart,\n  debug: debug\n};\n"],"sourceRoot":"webpack-module://"}