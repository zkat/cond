{"version":3,"file":"cond.min.js","sources":["webpack/universalModuleDefinition","cond.min.js","webpack/bootstrap 033d58c55d4544b737d7*","./src/index.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","warn","cond","arguments","Warning","signal","apply","cerror","error","x","concat","slice","Error","length","_signal","recoverable","oldClusters","HANDLER_CLUSTERS","forEach","cluster","handlerEntry","handlerBind","handledBody","handlers","e","handlerCase","sentinel","map","handler","recoverableBody","oldRecoveries","RECOVERIES","recoveries","entry","name","description","callback","args","recover","_recover","recovery","Array","isArray","findRecovery","recoveryArgs","oldThis","i","undefined","debug","condition","__chosenRecovery","__recoveryArgs","prototype","constructor","w","console"],"mappings":"CAAA,SAAAA,EAAAC,GACA,gBAAAC,UAAA,gBAAAC,QACAA,OAAAD,QAAAD,IACA,kBAAAG,gBAAAC,IACAD,OAAAH,GACA,gBAAAC,SACAA,QAAA,KAAAD,IAEAD,EAAA,KAAAC,KACCK,KAAA,WACD,MCAgB,UAAUC,GCL1B,QAAAC,GAAAC,GAEA,GAAAC,EAAAD,GACA,MAAAC,GAAAD,GAAAP,OAGA,IAAAC,GAAAO,EAAAD,IACAP,WACAS,GAAAF,EACAG,QAAA,EAUA,OANAL,GAAAE,GAAAI,KAAAV,EAAAD,QAAAC,IAAAD,QAAAM,GAGAL,EAAAS,QAAA,EAGAT,EAAAD,QAtBA,GAAAQ,KAqCA,OAVAF,GAAAM,EAAAP,EAGAC,EAAAO,EAAAL,EAGAF,EAAAQ,EAAA,GAIAR,EAAA,KDgBM,SAASL,GEvDf,YAeA,SAAAc,GAAAC,GAEA,MADAC,WAAA,mBAAAD,GAAA,GAAAE,GAAAF,KACAG,EAAAC,MAAAhB,KAAAa,WAGA,QAAAC,MAmBA,QAAAG,KACA,MAAAC,GAAAF,MAAAhB,MACAa,UAAA,IACA,WACA,sDACA,SAAAM,GAAiB,MAAAA,MACjBC,UAAAC,MAAAd,KAAAM,UAAA,KAsBA,QAAAK,GAAAN,GAEA,MADAC,WAAA,mBAAAD,GAAA,GAAAU,OAAAV,KACAG,EAAAC,MAAAhB,KAAAa,WAmBA,QAAAE,GAAAH,GACA,MAAAC,WAAAU,QAAA,EACAC,EAAAZ,GAEAa,EAAAT,MACAhB,MACA,WAAkB,MAAAwB,GAAAZ,KAAsBQ,UAAAC,MAAAd,KAAAM,UAAA,KAIxC,QAAAW,GAAAZ,GACA,GAAAc,GAAAC,CACA,KACAA,EAAAC,QAAA,SAAAC,GACAF,IAAAN,MAAA,GACAQ,EAAAD,QAAA,SAAAE,GACA,kBAAAA,GACAA,EAAAlB,GACSA,YAAAkB,GAAA,IACTA,EAAA,GAAAlB,OAIG,QACHe,EAAAD,GAIA,QAAAK,GAAAC,GACA,GAAAC,MAAAZ,MAAAd,KAAAM,UAAA,GACAa,EAAAC,CACA,KAEA,MADAA,IAAAM,GAAAb,OAAAO,GACAK,EAAAzB,KAAAP,MACG,MAAAkC,GAEH,KADAnB,GAAAmB,GACAA,EACG,QACHP,EAAAD,GAIA,QAAAS,GAAAH,GACA,GAAAI,MACAH,KAAAZ,MAAAd,KAAAM,UAAA,GAAAwB,IAAA,SAAAP,GACA,OAAAA,EAAA,YAAAI,GAGA,KAFAE,GAAAE,QAAAR,EAAA,GACAM,EAAAlB,MAAAgB,EACAE,KAGA,KACA,MAAAL,GAAAf,MAAAhB,MAAAgC,GAAAZ,OAAAa,IACG,MAAAC,GACH,GAAAA,IAAAE,EACA,MAAAA,GAAAE,QAAA/B,KAAAP,KAAAoC,EAAAlB,MAEA,MAAAgB,IAaA,QAAAT,GAAAc,GACA,GAAAH,MACAI,EAAAC,EACAC,KAAArB,MAAAd,KAAAM,UAAA,GAAAwB,IAAA,SAAAM,GACA,GAAAC,GAAAD,EAAA,GACAE,EAAA,gBAAAF,GAAA,GAAAA,EAAA,MACAG,EAAAD,EAAAF,EAAA,GAAAA,EAAA,EACA,QAAAC,EAAAC,EAAA,WAGA,KAFAT,GAAAU,WACAV,EAAAW,KAAAlC,UACAuB,KAGA,KAEA,MADAK,GAAAC,EAAAtB,OAAAqB,GACAF,EAAAhC,KAAAP,MACG,MAAAkC,GACH,GAAAA,IAAAE,EACA,MAAAA,GAAAU,SAAA9B,MAAAhB,KAAAoC,EAAAW,KAEA,MAAAb,GAEG,QACHO,EAAAD,GAIA,QAAAQ,KACA,MAAAC,GAAAjC,MAAAhB,KAAAa,WAEA,QAAAoC,GAAAL,GACA,GAAAM,GAAAC,MAAAC,QAAAR,KAAAS,EAAAT,GACAU,KAAAjC,MAAAd,KAAAM,UAAA,GACA0C,EAAAvD,IACA,OAAAkD,GACAA,IAAA3B,OAAA,GAAAP,MAAAhB,KAAAsD,GAEApC,EAAA,uBAAA0B,GACA,8DACA,MAAAI,GAAAhC,MAAAuC,EAAAD,MAOA,QAAAD,GAAAT,GACA,mBAAAA,GAAA,CACA,OAAAY,GAAA,EAAmBA,EAAAf,EAAAlB,OAAuBiC,IAC1C,GAAAZ,IAAAH,EAAAe,GAAA,GACA,MAAAf,GAAAe,EAGA,OAAAC,QAEA,MAAAhB,GAAAG,GAOA,QAAAc,GAAAC,GAcA,GAAAC,GACAC,CA2BA,UAAAD,EAGA,KAAAD,EAFAV,GAAAjC,MAAAhB,KAAA6D,GAlPA/C,EAAAgD,UAAA,GAAAxC,OACAR,EAAAgD,UAAAC,YAAAjD,CAmQA,IAAAa,MACAb,EAAA,SAAAkD,GAAyBC,QAAAtD,KAAAqD,KAEzBN,IAEAjB,IAGA5C,GAAAD,SACAmB,SACAG,QACAD,SACAN,OACAG,UACAiB,cACAI,cACAV,cACAuB,UACAK,eACAK","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"cond\"] = factory();\n\telse\n\t\troot[\"cond\"] = factory();\n})(this, function() {\nreturn ","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"cond\"] = factory();\n\telse\n\t\troot[\"cond\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/ \t\t\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/ \t\t\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/ \t\t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/******/ \t\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/ \t\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/ \t\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/ \t\n/******/ \t\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\t/**\n\t * Signals a warning condition. By default, warnings do not trigger the\n\t * debugger, but they console.warn the condition.\n\t *\n\t * @param {string|*} condition - The condition to signal. If `condition` is a\n\t *                               string, it will be turned into a Warning and\n\t *                               that warning will be signaled.\n\t * @param {...Array} recoveries - Recoveries to make available. An invoked\n\t *                                recovery will replace the value of the\n\t *                                `warn()` call.\n\t *\n\t * @returns `undefined` or the value of the invoked recovery.\n\t */\n\tfunction warn(cond) {\n\t  arguments[0] = typeof cond === \"string\" ? new Warning(cond) : cond;\n\t  return signal.apply(this, arguments);\n\t}\n\t\n\tfunction Warning() {}\n\tWarning.prototype = new Error;\n\tWarning.prototype.constructor = Warning;\n\t\n\t/**\n\t * Signals a continuable error. This function is identical to `error()`, except\n\t * it makes a `\"continue\"` recovery available. Invoking this recovery will allow\n\t * execution to continue normally. The recovery can optionally be given a value\n\t * that `cerror()` will return.\n\t *\n\t * @param {string|*} condition - The condition to signal. If `condition` is a\n\t *                               string, it will be turned into an Error before\n\t *                               being signaled.\n\t * @param {...Array} recoveries - Recoveries to make available. An invoked\n\t *                                recovery will replace the value of the\n\t *                                `cerror()` call.\n\t *\n\t * @returns The value of the invoked recovery.\n\t */\n\tfunction cerror() {\n\t  return error.apply(this, [\n\t    arguments[0],\n\t    [\"continue\",\n\t     \"Return undefined (or a value) and continue normally\",\n\t     function(x){return x;}]\n\t  ].concat([].slice.call(arguments, 1)));\n\t}\n\t\n\t/**\n\t * Signals an error. Optionally accepts one or more recoveries, which may\n\t * replace the value of the `error()` call.\n\t *\n\t * @param {string|*} condition - The condition to signal. If `condition` is a\n\t *                               string, it will be turned into an Error before\n\t *                               being signaled.\n\t * @param {...Array} recoveries - Recoveries to make available. An invoked\n\t *                                recovery will replace the value of the\n\t *                                `error()` call.\n\t *\n\t * @returns The value of the invoked recovery.\n\t *\n\t * @example\n\t * cond.error(\"Kaboom\");\n\t * cond.error(\"Something exploded\",\n\t *            [\"gimme-5\", \"Just returns 5\", function() { return 5; }]);\n\t * cond.error(new CustomError(\"Goodbye\"));\n\t */\n\tfunction error(cond) {\n\t  arguments[0] = typeof cond === \"string\" ? new Error(cond) : cond;\n\t  return signal.apply(this, arguments);\n\t}\n\t\n\t/**\n\t * Signals a condition. Optionally accepts one or more recoveries, which may\n\t * replace the value of the `signal()` call.\n\t *\n\t * @param {*} condition - The condition to signal.\n\t * @param {...Array} recoveries - Recoveries to make available. An invoked\n\t *                                recovery will replace the value of the\n\t *                                `signal()` call.\n\t *\n\t * @returns The value of the invoked recovery.\n\t *\n\t * @example\n\t * cond.signal(new InvalidEntry(entry));\n\t * cond.signal(new NotANumberError(num),\n\t *            [\"gimme-5\", \"Just returns 5\", function() { return 5; }]);\n\t */\n\tfunction signal(cond) {\n\t  if (arguments.length <= 1) {\n\t    return _signal(cond);\n\t  } else {\n\t    return recoverable.apply(\n\t      this,\n\t      [function(){return _signal(cond);}].concat([].slice.call(arguments, 1)));\n\t  }\n\t}\n\t\n\tfunction _signal(cond) {\n\t  var oldClusters = HANDLER_CLUSTERS;\n\t  try {\n\t    HANDLER_CLUSTERS.forEach(function(cluster) {\n\t      HANDLER_CLUSTERS = HANDLER_CLUSTERS.slice(1);\n\t      cluster.forEach(function(handlerEntry) {\n\t        if (typeof handlerEntry === \"function\") {\n\t          handlerEntry(cond);\n\t        } else if (cond instanceof handlerEntry[0]) {\n\t          handlerEntry[1](cond);\n\t        }\n\t      });\n\t    });\n\t  } finally {\n\t    HANDLER_CLUSTERS = oldClusters;\n\t  }\n\t}\n\t\n\tfunction handlerBind(handledBody) {\n\t  var handlers = [].slice.call(arguments, 1),\n\t      oldClusters = HANDLER_CLUSTERS;\n\t  try {\n\t    HANDLER_CLUSTERS = [handlers].concat(HANDLER_CLUSTERS);\n\t    return handledBody.call(this);\n\t  } catch (e) {\n\t    signal(e);\n\t    throw e;\n\t  } finally {\n\t    HANDLER_CLUSTERS = oldClusters;\n\t  }\n\t}\n\t\n\tfunction handlerCase(handledBody) {\n\t  var sentinel = {},\n\t      handlers = [].slice.call(arguments, 1).map(function(handlerEntry) {\n\t        return [handlerEntry[0], function(e) {\n\t          sentinel.handler = handlerEntry[1];\n\t          sentinel.error = e;\n\t          throw sentinel;\n\t        }];\n\t      });\n\t  try {\n\t    return handlerBind.apply(this, [handledBody].concat(handlers));\n\t  } catch (e) {\n\t    if (e === sentinel) {\n\t      return sentinel.handler.call(this, sentinel.error);\n\t    } else {\n\t      throw e;\n\t    }\n\t  }\n\t}\n\t\n\tfunction listRecoveries() {\n\t  // \"Deep enough\" copy to protect the internal RECOVERIES array structure from\n\t  // user shenanigans.\n\t  return RECOVERIES.map(function(x) {\n\t    return x.map(function(x) { return x; });\n\t  });\n\t}\n\t\n\tfunction recoverable(recoverableBody) {\n\t  var sentinel = {},\n\t      oldRecoveries = RECOVERIES,\n\t      recoveries = [].slice.call(arguments, 1).map(function(entry) {\n\t        var name = entry[0],\n\t            description = typeof entry[1] === \"string\" ? entry[1] : \"\",\n\t            callback = description ? entry[2] : entry[1];\n\t        return [name, description, function() {\n\t          sentinel.callback = callback;\n\t          sentinel.args = arguments;\n\t          throw sentinel;\n\t        }];\n\t      });\n\t  try {\n\t    RECOVERIES = recoveries.concat(RECOVERIES);\n\t    return recoverableBody.call(this);\n\t  } catch(e) {\n\t    if (e === sentinel) {\n\t      return sentinel.callback.apply(this, sentinel.args);\n\t    } else {\n\t      throw e;\n\t    }\n\t  } finally {\n\t    RECOVERIES = oldRecoveries;\n\t  }\n\t}\n\t\n\tfunction recover(name) {\n\t  return _recover.apply(this, arguments);\n\t}\n\tfunction _recover(name) {\n\t  var recovery = Array.isArray(name) ? name : findRecovery(name),\n\t      recoveryArgs = [].slice.call(arguments, 1),\n\t      oldThis = this;\n\t  if (recovery) {\n\t    return recovery[recovery.length-1].apply(this, recoveryArgs);\n\t  } else {\n\t    return error(\"Recovery not found: \"+name, [\n\t      \"try-again\", \"Call recover() again with a new name\", function(x) {\n\t        return recover.apply(oldThis, recoveryArgs);\n\t      }\n\t    ]);\n\t\n\t  }\n\t}\n\t\n\tfunction findRecovery(name) {\n\t  if (typeof name === \"string\") {\n\t    for (var i = 0; i < RECOVERIES.length; i++) {\n\t      if (name === RECOVERIES[i][0]) {\n\t        return RECOVERIES[i];\n\t      }\n\t    }\n\t    return undefined;\n\t  } else {\n\t    return RECOVERIES[name];\n\t  }\n\t}\n\t\n\t/**\n\t * Invokes the configured debugger.\n\t */\n\tfunction debug(condition) {\n\t  /*****************************************************************/\n\t  /* Welcome to the */ debugger; /* Read below for instructions!!! */\n\t  /*                                                               */\n\t  /* Recoveries may be available.                                  */\n\t  /* Call showRecoveries() in the JS console to list them.         */\n\t  /*                                                               */\n\t  /* If you pick a recovery, it will be invoked after you unpause  */\n\t  /* the debugger. Otherwise, `condition` will be thrown.          */\n\t  /*                                                               */\n\t  /*                Thanks for using CondJS!                       */\n\t  /*                                                               */\n\t  /*****************************************************************/\n\t\n\t  var __chosenRecovery,\n\t      __recoveryArgs;\n\t  function recover(name) {\n\t    var recovery = findRecovery(name);\n\t    if (recovery) {\n\t      __chosenRecovery = RECOVERIES.indexOf(recovery);\n\t      __recoveryArgs = arguments;\n\t      console.log(\"Selected recovery: [\"+__chosenRecovery+\"] \"+recovery[0]);\n\t      console.log(\"Unpause the debugger to continue.\");\n\t    } else {\n\t      console.log(\"Invalid recovery: \", name);\n\t      console.log(\"Use showRecoveries() to see a list of available recoveries\");\n\t    }\n\t  }\n\t  function showRecoveries() {\n\t    console.log(\n\t      (((condition && condition.toString) ? condition.toString() + \"\\n\": \"\") +\n\t       \"Available recoveries: \\n\" +\n\t       \"\\n\" +\n\t       RECOVERIES.reduce(function(acc, entry, i) {\n\t         return acc + formatRecovery(entry, i) + \"\\n\";\n\t       }, \"\") + \"\\n\" +\n\t       \"To use a recovery: `recover(<name or index>[, arg1[, arg2 ...]])`\\n\"+\n\t       \"\\n\" +\n\t       \"Unpause your debugger to continue.\" +\n\t       \"\"));\n\t  }\n\t\n\t  if (__chosenRecovery != null) {\n\t    _recover.apply(this, __recoveryArgs);\n\t  } else {\n\t    throw condition;\n\t  }\n\t}\n\t\n\tfunction formatRecovery(entry, i) {\n\t  var name = entry[0],\n\t      description = (typeof entry[1] === \"string\" && entry[1].length) ?\n\t        \": \"+entry[1] :\n\t        \"\";\n\t  return \"[\"+i+\"] \"+entry[0]+description;\n\t}\n\t\n\t/*\n\t * Internals\n\t */\n\t\n\tvar HANDLER_CLUSTERS = [[\n\t  [Warning, function(w) { console.warn(w); }],\n\t  // If we get anything else unhandled, force falling back into the debugger.\n\t  debug\n\t]],\n\t    RECOVERIES = [];\n\t\n\t\n\tmodule.exports = {\n\t  signal: signal,\n\t  error: error,\n\t  cerror: cerror,\n\t  warn: warn,\n\t  Warning: Warning,\n\t  handlerBind: handlerBind,\n\t  handlerCase: handlerCase,\n\t  recoverable: recoverable,\n\t  recover: recover,\n\t  findRecovery: findRecovery,\n\t  debug: debug\n\t};\n\n\n/***/ }\n/******/ ])\n})\n","\n// The module cache\nvar installedModules = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tif(installedModules[moduleId])\n\t\treturn installedModules[moduleId].exports;\n\t\n\t// Create a new module (and put it into the cache)\n\tvar module = installedModules[moduleId] = {\n\t\texports: {},\n\t\tid: moduleId,\n\t\tloaded: false\n\t};\n\t\n\t// Execute the module function\n\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\t\n\t// Flag the module as loaded\n\tmodule.loaded = true;\n\t\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = modules;\n\n// expose the module cache\n__webpack_require__.c = installedModules;\n\n// __webpack_public_path__\n__webpack_require__.p = \"\";\n\n\n// Load entry module and return exports\nreturn __webpack_require__(0);","\"use strict\";\n\n/**\n * Signals a warning condition. By default, warnings do not trigger the\n * debugger, but they console.warn the condition.\n *\n * @param {string|*} condition - The condition to signal. If `condition` is a\n *                               string, it will be turned into a Warning and\n *                               that warning will be signaled.\n * @param {...Array} recoveries - Recoveries to make available. An invoked\n *                                recovery will replace the value of the\n *                                `warn()` call.\n *\n * @returns `undefined` or the value of the invoked recovery.\n */\nfunction warn(cond) {\n  arguments[0] = typeof cond === \"string\" ? new Warning(cond) : cond;\n  return signal.apply(this, arguments);\n}\n\nfunction Warning() {}\nWarning.prototype = new Error;\nWarning.prototype.constructor = Warning;\n\n/**\n * Signals a continuable error. This function is identical to `error()`, except\n * it makes a `\"continue\"` recovery available. Invoking this recovery will allow\n * execution to continue normally. The recovery can optionally be given a value\n * that `cerror()` will return.\n *\n * @param {string|*} condition - The condition to signal. If `condition` is a\n *                               string, it will be turned into an Error before\n *                               being signaled.\n * @param {...Array} recoveries - Recoveries to make available. An invoked\n *                                recovery will replace the value of the\n *                                `cerror()` call.\n *\n * @returns The value of the invoked recovery.\n */\nfunction cerror() {\n  return error.apply(this, [\n    arguments[0],\n    [\"continue\",\n     \"Return undefined (or a value) and continue normally\",\n     function(x){return x;}]\n  ].concat([].slice.call(arguments, 1)));\n}\n\n/**\n * Signals an error. Optionally accepts one or more recoveries, which may\n * replace the value of the `error()` call.\n *\n * @param {string|*} condition - The condition to signal. If `condition` is a\n *                               string, it will be turned into an Error before\n *                               being signaled.\n * @param {...Array} recoveries - Recoveries to make available. An invoked\n *                                recovery will replace the value of the\n *                                `error()` call.\n *\n * @returns The value of the invoked recovery.\n *\n * @example\n * cond.error(\"Kaboom\");\n * cond.error(\"Something exploded\",\n *            [\"gimme-5\", \"Just returns 5\", function() { return 5; }]);\n * cond.error(new CustomError(\"Goodbye\"));\n */\nfunction error(cond) {\n  arguments[0] = typeof cond === \"string\" ? new Error(cond) : cond;\n  return signal.apply(this, arguments);\n}\n\n/**\n * Signals a condition. Optionally accepts one or more recoveries, which may\n * replace the value of the `signal()` call.\n *\n * @param {*} condition - The condition to signal.\n * @param {...Array} recoveries - Recoveries to make available. An invoked\n *                                recovery will replace the value of the\n *                                `signal()` call.\n *\n * @returns The value of the invoked recovery.\n *\n * @example\n * cond.signal(new InvalidEntry(entry));\n * cond.signal(new NotANumberError(num),\n *            [\"gimme-5\", \"Just returns 5\", function() { return 5; }]);\n */\nfunction signal(cond) {\n  if (arguments.length <= 1) {\n    return _signal(cond);\n  } else {\n    return recoverable.apply(\n      this,\n      [function(){return _signal(cond);}].concat([].slice.call(arguments, 1)));\n  }\n}\n\nfunction _signal(cond) {\n  var oldClusters = HANDLER_CLUSTERS;\n  try {\n    HANDLER_CLUSTERS.forEach(function(cluster) {\n      HANDLER_CLUSTERS = HANDLER_CLUSTERS.slice(1);\n      cluster.forEach(function(handlerEntry) {\n        if (typeof handlerEntry === \"function\") {\n          handlerEntry(cond);\n        } else if (cond instanceof handlerEntry[0]) {\n          handlerEntry[1](cond);\n        }\n      });\n    });\n  } finally {\n    HANDLER_CLUSTERS = oldClusters;\n  }\n}\n\nfunction handlerBind(handledBody) {\n  var handlers = [].slice.call(arguments, 1),\n      oldClusters = HANDLER_CLUSTERS;\n  try {\n    HANDLER_CLUSTERS = [handlers].concat(HANDLER_CLUSTERS);\n    return handledBody.call(this);\n  } catch (e) {\n    signal(e);\n    throw e;\n  } finally {\n    HANDLER_CLUSTERS = oldClusters;\n  }\n}\n\nfunction handlerCase(handledBody) {\n  var sentinel = {},\n      handlers = [].slice.call(arguments, 1).map(function(handlerEntry) {\n        return [handlerEntry[0], function(e) {\n          sentinel.handler = handlerEntry[1];\n          sentinel.error = e;\n          throw sentinel;\n        }];\n      });\n  try {\n    return handlerBind.apply(this, [handledBody].concat(handlers));\n  } catch (e) {\n    if (e === sentinel) {\n      return sentinel.handler.call(this, sentinel.error);\n    } else {\n      throw e;\n    }\n  }\n}\n\nfunction listRecoveries() {\n  // \"Deep enough\" copy to protect the internal RECOVERIES array structure from\n  // user shenanigans.\n  return RECOVERIES.map(function(x) {\n    return x.map(function(x) { return x; });\n  });\n}\n\nfunction recoverable(recoverableBody) {\n  var sentinel = {},\n      oldRecoveries = RECOVERIES,\n      recoveries = [].slice.call(arguments, 1).map(function(entry) {\n        var name = entry[0],\n            description = typeof entry[1] === \"string\" ? entry[1] : \"\",\n            callback = description ? entry[2] : entry[1];\n        return [name, description, function() {\n          sentinel.callback = callback;\n          sentinel.args = arguments;\n          throw sentinel;\n        }];\n      });\n  try {\n    RECOVERIES = recoveries.concat(RECOVERIES);\n    return recoverableBody.call(this);\n  } catch(e) {\n    if (e === sentinel) {\n      return sentinel.callback.apply(this, sentinel.args);\n    } else {\n      throw e;\n    }\n  } finally {\n    RECOVERIES = oldRecoveries;\n  }\n}\n\nfunction recover(name) {\n  return _recover.apply(this, arguments);\n}\nfunction _recover(name) {\n  var recovery = Array.isArray(name) ? name : findRecovery(name),\n      recoveryArgs = [].slice.call(arguments, 1),\n      oldThis = this;\n  if (recovery) {\n    return recovery[recovery.length-1].apply(this, recoveryArgs);\n  } else {\n    return error(\"Recovery not found: \"+name, [\n      \"try-again\", \"Call recover() again with a new name\", function(x) {\n        return recover.apply(oldThis, recoveryArgs);\n      }\n    ]);\n\n  }\n}\n\nfunction findRecovery(name) {\n  if (typeof name === \"string\") {\n    for (var i = 0; i < RECOVERIES.length; i++) {\n      if (name === RECOVERIES[i][0]) {\n        return RECOVERIES[i];\n      }\n    }\n    return undefined;\n  } else {\n    return RECOVERIES[name];\n  }\n}\n\n/**\n * Invokes the configured debugger.\n */\nfunction debug(condition) {\n  /*****************************************************************/\n  /* Welcome to the */ debugger; /* Read below for instructions!!! */\n  /*                                                               */\n  /* Recoveries may be available.                                  */\n  /* Call showRecoveries() in the JS console to list them.         */\n  /*                                                               */\n  /* If you pick a recovery, it will be invoked after you unpause  */\n  /* the debugger. Otherwise, `condition` will be thrown.          */\n  /*                                                               */\n  /*                Thanks for using CondJS!                       */\n  /*                                                               */\n  /*****************************************************************/\n\n  var __chosenRecovery,\n      __recoveryArgs;\n  function recover(name) {\n    var recovery = findRecovery(name);\n    if (recovery) {\n      __chosenRecovery = RECOVERIES.indexOf(recovery);\n      __recoveryArgs = arguments;\n      console.log(\"Selected recovery: [\"+__chosenRecovery+\"] \"+recovery[0]);\n      console.log(\"Unpause the debugger to continue.\");\n    } else {\n      console.log(\"Invalid recovery: \", name);\n      console.log(\"Use showRecoveries() to see a list of available recoveries\");\n    }\n  }\n  function showRecoveries() {\n    console.log(\n      (((condition && condition.toString) ? condition.toString() + \"\\n\": \"\") +\n       \"Available recoveries: \\n\" +\n       \"\\n\" +\n       RECOVERIES.reduce(function(acc, entry, i) {\n         return acc + formatRecovery(entry, i) + \"\\n\";\n       }, \"\") + \"\\n\" +\n       \"To use a recovery: `recover(<name or index>[, arg1[, arg2 ...]])`\\n\"+\n       \"\\n\" +\n       \"Unpause your debugger to continue.\" +\n       \"\"));\n  }\n\n  if (__chosenRecovery != null) {\n    _recover.apply(this, __recoveryArgs);\n  } else {\n    throw condition;\n  }\n}\n\nfunction formatRecovery(entry, i) {\n  var name = entry[0],\n      description = (typeof entry[1] === \"string\" && entry[1].length) ?\n        \": \"+entry[1] :\n        \"\";\n  return \"[\"+i+\"] \"+entry[0]+description;\n}\n\n/*\n * Internals\n */\n\nvar HANDLER_CLUSTERS = [[\n  [Warning, function(w) { console.warn(w); }],\n  // If we get anything else unhandled, force falling back into the debugger.\n  debug\n]],\n    RECOVERIES = [];\n\n\nmodule.exports = {\n  signal: signal,\n  error: error,\n  cerror: cerror,\n  warn: warn,\n  Warning: Warning,\n  handlerBind: handlerBind,\n  handlerCase: handlerCase,\n  recoverable: recoverable,\n  recover: recover,\n  findRecovery: findRecovery,\n  debug: debug\n};\n"],"sourceRoot":"webpack-module://"}