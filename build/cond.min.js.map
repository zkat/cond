{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///cond.min.js","webpack:///webpack/bootstrap b5a0ffe402abe91a29f8","webpack:///./src/index.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","warn","cond","arguments","Warning","signal","apply","cerror","error","x","concat","slice","Error","length","_signal","recoverable","oldClusters","HANDLER_CLUSTERS","forEach","cluster","_signalCluster","handlerEntry","handlerBind","handledBody","handlers","oldInHandler","IN_HANDLER_SCOPE","e","Sentinel","fromDebug","condition","handlerCase","sentinel","map","handlerCallback","handler","oldCallback","isArrayEntry","Array","isArray","recoverableBody","oldRecoveries","RECOVERIES","recoveries","entry","name","description","callback","args","recover","_recover","recovery","findRecovery","recoveryArgs","oldThis","i","undefined","debug","__chosenRecovery","__recoveryArgs","prototype","constructor","w","console"],"mappings":"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","file":"cond.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"cond\"] = factory();\n\telse\n\t\troot[\"cond\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"cond\"] = factory();\n\telse\n\t\troot[\"cond\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\t/**\n\t * Signals a warning condition. By default, warnings do not trigger the\n\t * debugger, but they console.warn the condition.\n\t *\n\t * @param {string|*} condition - The condition to signal. If `condition` is a\n\t *                               string, it will be turned into a Warning and\n\t *                               that warning will be signaled.\n\t * @param {...Array} recoveries - Recoveries to make available. An invoked\n\t *                                recovery will replace the value of the\n\t *                                `warn()` call.\n\t *\n\t * @returns `undefined` or the value of the invoked recovery.\n\t */\n\tfunction warn(cond) {\n\t  arguments[0] = typeof cond === \"string\" ? new Warning(cond) : cond;\n\t  return signal.apply(this, arguments);\n\t}\n\t\n\tfunction Warning() {}\n\tWarning.prototype = new Error;\n\tWarning.prototype.constructor = Warning;\n\t\n\t/**\n\t * Signals a continuable error. This function is identical to `error()`, except\n\t * it makes a `\"continue\"` recovery available. Invoking this recovery will allow\n\t * execution to continue normally. The recovery can optionally be given a value\n\t * that `cerror()` will return.\n\t *\n\t * @param {string|*} condition - The condition to signal. If `condition` is a\n\t *                               string, it will be turned into an Error before\n\t *                               being signaled.\n\t * @param {...Array} recoveries - Recoveries to make available. An invoked\n\t *                                recovery will replace the value of the\n\t *                                `cerror()` call.\n\t *\n\t * @returns The value of the invoked recovery.\n\t */\n\tfunction cerror() {\n\t  return error.apply(this, [\n\t    arguments[0],\n\t    [\"continue\",\n\t     \"Return undefined (or a value) and continue normally\",\n\t     function(x){return x;}]\n\t  ].concat([].slice.call(arguments, 1)));\n\t}\n\t\n\t/**\n\t * Signals an error. Optionally accepts one or more recoveries, which may\n\t * replace the value of the `error()` call.\n\t *\n\t * @param {string|*} condition - The condition to signal. If `condition` is a\n\t *                               string, it will be turned into an Error before\n\t *                               being signaled.\n\t * @param {...Array} recoveries - Recoveries to make available. An invoked\n\t *                                recovery will replace the value of the\n\t *                                `error()` call.\n\t *\n\t * @returns The value of the invoked recovery.\n\t *\n\t * @example\n\t * cond.error(\"Kaboom\");\n\t * cond.error(\"Something exploded\",\n\t *            [\"gimme-5\", \"Just returns 5\", function() { return 5; }]);\n\t * cond.error(new CustomError(\"Goodbye\"));\n\t */\n\tfunction error(cond) {\n\t  arguments[0] = typeof cond === \"string\" ? new Error(cond) : cond;\n\t  return signal.apply(this, arguments);\n\t}\n\t\n\t/**\n\t * Signals a condition. Optionally accepts one or more recoveries, which may\n\t * replace the value of the `signal()` call.\n\t *\n\t * @param {*} condition - The condition to signal.\n\t * @param {...Array} recoveries - Recoveries to make available. An invoked\n\t *                                recovery will replace the value of the\n\t *                                `signal()` call.\n\t *\n\t * @returns The value of the invoked recovery.\n\t *\n\t * @example\n\t * cond.signal(new InvalidEntry(entry));\n\t * cond.signal(new NotANumberError(num),\n\t *            [\"gimme-5\", \"Just returns 5\", function() { return 5; }]);\n\t */\n\tfunction signal(cond) {\n\t  if (arguments.length <= 1) {\n\t    return _signal(cond);\n\t  } else {\n\t    return recoverable.apply(\n\t      this,\n\t      [function(){return _signal(cond);}].concat([].slice.call(arguments, 1)));\n\t  }\n\t}\n\t\n\tfunction _signal(cond) {\n\t  var oldClusters = HANDLER_CLUSTERS;\n\t  try {\n\t    HANDLER_CLUSTERS.forEach(function(cluster) {\n\t      HANDLER_CLUSTERS = HANDLER_CLUSTERS.slice(1);\n\t      _signalCluster(cond, cluster);\n\t    });\n\t  } finally {\n\t    HANDLER_CLUSTERS = oldClusters;\n\t  }\n\t}\n\t\n\tfunction _signalCluster(cond, cluster) {\n\t  cluster.forEach(function(handlerEntry) {\n\t    if (typeof handlerEntry === \"function\") {\n\t      handlerEntry(cond);\n\t    } else if (typeof cond === \"object\" &&\n\t               cond instanceof handlerEntry[0]) {\n\t      handlerEntry[1](cond);\n\t    }\n\t  });\n\t}\n\t\n\t/**\n\t * Executes `handledBody` in a dynamic context with a set of given handlers\n\t * installed. Handlers can either be arrays of `[Constructor, handler]`, or\n\t * simply a lone function. In the array form, the handler will be called\n\t * whenever a condition is signaled which is `instanceof` that `Constructor`. In\n\t * the cases of a solo function handler, the handler will be unconditionally\n\t * executed.\n\t *\n\t * Note that handlerBind handlers do not automatically catch signals. In order\n\t * to handle/catch a signal, the handler callback must perform its own non-local\n\t * exit from the execution context. To automatically catch when a handler\n\t * matches, use `handlerCase()` instead.\n\t *\n\t * @param {Function} handledBody - Function to execute in a handled dynamic\n\t *                                 context.\n\t * @param {...Array|Function} handlers - Handlers to execute on matching\n\t *                                       signals. Executed first to last.\n\t *\n\t * @returns The value of `handledBody`.\n\t *\n\t * @example\n\t * cond.handlerBind(function() {\n\t *   cond.error(\"fail\");\n\t * }, [Error, console.error],\n\t *    [Error, function() { console.log(\"This one, too\"); }]);\n\t */\n\tfunction handlerBind(handledBody) {\n\t  var handlers = [].slice.call(arguments, 1),\n\t      oldInHandler = IN_HANDLER_SCOPE,\n\t      oldClusters = HANDLER_CLUSTERS;\n\t  try {\n\t    HANDLER_CLUSTERS = [handlers].concat(HANDLER_CLUSTERS);\n\t    IN_HANDLER_SCOPE = true;\n\t    return handledBody.call(this);\n\t  } catch(e) {\n\t    if (!(e instanceof Sentinel)) {\n\t      _signalCluster(e, handlers);\n\t    } else if (e instanceof Sentinel && e.fromDebug && !oldInHandler) {\n\t      throw e.condition;\n\t    }\n\t    throw e;\n\t  } finally {\n\t    HANDLER_CLUSTERS = oldClusters;\n\t    IN_HANDLER_SCOPE = oldInHandler;\n\t  }\n\t}\n\t\n\t/**\n\t * Executes `handledBody` in a dynamic execution context with a set of handlers\n\t * installed. Handlers passed to `handlerCase` will automatically catch/handle\n\t * signals, unlike `handlerBind`.\n\t *\n\t * @param {Function} handledBody - Function to execute in a handled dynamic\n\t *                                 context.\n\t * @param {...Array|Function} handlers - Handlers to execute on matching\n\t *                                       signals. Checked first to last.\n\t *\n\t * @returns The value of `handledBody`, or the value of a successful handler.\n\t *\n\t * @example\n\t * cond.handlerCase(function() {\n\t *   cond.error(\"fail\");\n\t * }, [Error, console.error],\n\t *    [Error, function() { console.log(\"This one won't be called\"); }]);\n\t */\n\tfunction handlerCase(handledBody) {\n\t  var sentinel = new Sentinel(),\n\t      handlers = [].slice.call(arguments, 1).map(function(handlerEntry) {\n\t        var isArrayEntry = Array.isArray(handlerEntry),\n\t            oldCallback = isArrayEntry ? handlerEntry[1] : handlerEntry;\n\t        if (isArrayEntry) {\n\t          return [handlerEntry[0], handlerCallback];\n\t        } else {\n\t          return handlerCallback;\n\t        }\n\t        function handlerCallback(e) {\n\t          sentinel.handler = oldCallback;\n\t          sentinel.error = e;\n\t          throw sentinel;\n\t        };\n\t      });\n\t  try {\n\t    return handlerBind.apply(this, [handledBody].concat(handlers));\n\t  } catch (e) {\n\t    if (e === sentinel) {\n\t      return sentinel.handler.call(this, sentinel.error);\n\t    } else {\n\t      throw e;\n\t    }\n\t  }\n\t}\n\t\n\tfunction listRecoveries() {\n\t  // \"Deep enough\" copy to protect the internal RECOVERIES array structure from\n\t  // user shenanigans.\n\t  return RECOVERIES.map(function(x) {\n\t    return x.map(function(x) { return x; });\n\t  });\n\t}\n\t\n\t/**\n\t * Executes `recoverableBody` as a recoverable block. Specified recoveries are\n\t * able to execute in the context of the `recoverable()` call, and any value\n\t * they return will be used to replace the value of the `recoverabl()` call.\n\t *\n\t * Usually, this feature is used by calling the `signal` family of\n\t * functions. `recoverable()` is mostly useful when wrapping non-`cond` code to\n\t * allow calls at your application level to be recoverable.\n\t *\n\t * @param {Function} recoverableBody - Function to execute.\n\t * @param {...Array} recoveries - Zero or more recoveries to be made available.\n\t *\n\t * @returns Either the return value of `recoverableBody`, if it succeeds, or the\n\t *          value returned by any invoked `recoveries` if it signals.\n\t *\n\t * @example\n\t * function someLibraryFunction() {\n\t *   throw new Error(\"I've never heard of CondJS\");\n\t * }\n\t *\n\t * cond.recoverable(function() {\n\t *   return someLibraryFunction();\n\t * }, [\"gimme-5\", \"Return 5\", function() { return 5; }]);\n\t */\n\tfunction recoverable(recoverableBody) {\n\t  var sentinel = new Sentinel(),\n\t      oldRecoveries = RECOVERIES,\n\t      recoveries = [].slice.call(arguments, 1).map(function(entry) {\n\t        var name = entry[0],\n\t            description = typeof entry[1] === \"string\" ? entry[1] : \"\",\n\t            callback = description ? entry[2] : entry[1];\n\t        return [name, description, function() {\n\t          sentinel.callback = callback;\n\t          sentinel.args = arguments;\n\t          throw sentinel;\n\t        }];\n\t      });\n\t  try {\n\t    RECOVERIES = recoveries.concat(RECOVERIES);\n\t    try {\n\t      return recoverableBody.call(this);\n\t    } catch(e) {\n\t      if (!(e instanceof Sentinel)) {\n\t        return _signal(e);\n\t      } else {\n\t        throw e;\n\t      }\n\t    }\n\t  } catch(e) {\n\t    if (e === sentinel) {\n\t      return sentinel.callback.apply(this, sentinel.args);\n\t    } else {\n\t      throw e;\n\t    }\n\t  } finally {\n\t    RECOVERIES = oldRecoveries;\n\t  }\n\t}\n\t\n\t/**\n\t * Used within a handler, will invoke a recovery by index, name, or even\n\t * directly if it was returned by `findRecovery()`\n\t *\n\t * @param {number|string|Array} - The recovery to invoke.\n\t *\n\t * @returns Nothing of value\n\t *\n\t * @example\n\t * cond.handlerBind(function() {\n\t *   return cerror(\"I'm making 'continue' available!\");\n\t * }, [Error, function(e) { cond.recover(\"continue\"); }]);\n\t */\n\tfunction recover(name) {\n\t  return _recover.apply(this, arguments);\n\t}\n\t\n\tfunction _recover(name) {\n\t  var recovery = Array.isArray(name) ? name : findRecovery(name),\n\t      recoveryArgs = [].slice.call(arguments, 1),\n\t      oldThis = this;\n\t  if (recovery) {\n\t    return recovery[recovery.length-1].apply(this, recoveryArgs);\n\t  } else {\n\t    return error(\"Recovery not found: \"+name, [\n\t      \"try-again\", \"Call recover() again with a new name\", function(x) {\n\t        return recover.apply(oldThis, recoveryArgs);\n\t      }\n\t    ]);\n\t\n\t  }\n\t}\n\t\n\t/**\n\t * Finds a recovery in the current dynamic context by name or index. The return\n\t * value of this function can be passed to `recover()` directly. No assumptions\n\t * should be made about the actual structure of the returned object, except that\n\t * `undefined` means no such recovery was found.\n\t *\n\t * @param {number|string} name - The name or index of the recovery.\n\t *\n\t * @returns {Array|undefined} recovery - The recovery found, or `undefined`.\n\t */\n\tfunction findRecovery(name) {\n\t  if (typeof name === \"string\") {\n\t    for (var i = 0; i < RECOVERIES.length; i++) {\n\t      if (name === RECOVERIES[i][0]) {\n\t        return RECOVERIES[i];\n\t      }\n\t    }\n\t    return undefined;\n\t  } else {\n\t    return RECOVERIES[name];\n\t  }\n\t}\n\t\n\t/**\n\t * Invokes the configured debugger.\n\t */\n\tfunction debug(condition) {\n\t  /*****************************************************************/\n\t  /* Welcome to the */ debugger; /* Read below for instructions!!! */\n\t  /*                                                               */\n\t  /* Recoveries may be available.                                  */\n\t  /* Call showRecoveries() in the JS console to list them.         */\n\t  /*                                                               */\n\t  /* If you pick a recovery, it will be invoked after you unpause  */\n\t  /* the debugger. Otherwise, `condition` will be thrown.          */\n\t  /*                                                               */\n\t  /*                Thanks for using CondJS!                       */\n\t  /*                                                               */\n\t  /*****************************************************************/\n\t\n\t  var __chosenRecovery,\n\t      __recoveryArgs;\n\t  function recover(name) {\n\t    var recovery = findRecovery(name);\n\t    if (recovery) {\n\t      __chosenRecovery = RECOVERIES.indexOf(recovery);\n\t      __recoveryArgs = arguments;\n\t      console.log(\"Selected recovery: [\"+__chosenRecovery+\"] \"+recovery[0]);\n\t      console.log(\"Unpause the debugger to continue.\");\n\t    } else {\n\t      console.log(\"Invalid recovery: \", name);\n\t      console.log(\"Use showRecoveries() to see a list of available recoveries\");\n\t    }\n\t  }\n\t  function showRecoveries() {\n\t    console.log(\n\t      (((condition && condition.toString) ? condition.toString() + \"\\n\": \"\") +\n\t       \"Available recoveries: \\n\" +\n\t       \"\\n\" +\n\t       RECOVERIES.reduce(function(acc, entry, i) {\n\t         return acc + formatRecovery(entry, i) + \"\\n\";\n\t       }, \"\") + \"\\n\" +\n\t       \"To use a recovery: `recover(<name or index>[, arg1[, arg2 ...]])`\\n\"+\n\t       \"\\n\" +\n\t       \"Unpause your debugger to continue.\" +\n\t       \"\"));\n\t  }\n\t\n\t  if (__chosenRecovery != null) {\n\t    _recover.apply(this, __recoveryArgs);\n\t  } else if (IN_HANDLER_SCOPE) {\n\t    var sentinel = new Sentinel();\n\t    sentinel.condition = condition;\n\t    sentinel.fromDebug = true;\n\t    throw sentinel;\n\t  } else {\n\t    throw condition;\n\t  }\n\t}\n\t\n\tfunction formatRecovery(entry, i) {\n\t  var name = entry[0],\n\t      description = (typeof entry[1] === \"string\" && entry[1].length) ?\n\t        \": \"+entry[1] :\n\t        \"\";\n\t  return \"[\"+i+\"] \"+entry[0]+description;\n\t}\n\t\n\t/*\n\t * Internals\n\t */\n\tfunction Sentinel() {}\n\t\n\tvar HANDLER_CLUSTERS = [[\n\t  [Warning, function(w) { console.warn(w); }],\n\t  // If we get anything else unhandled, force falling back into the debugger.\n\t  // Unless it's a warning, which we treat special.\n\t  function(c) {if (c instanceof Warning) { return; } else { debug(c); }}\n\t]],\n\t    RECOVERIES = [],\n\t    IN_HANDLER_SCOPE;\n\t\n\t\n\tmodule.exports = {\n\t  signal: signal,\n\t  error: error,\n\t  cerror: cerror,\n\t  warn: warn,\n\t  Warning: Warning,\n\t  handlerBind: handlerBind,\n\t  handlerCase: handlerCase,\n\t  recoverable: recoverable,\n\t  recover: recover,\n\t  findRecovery: findRecovery,\n\t  debug: debug\n\t};\n\n\n/***/ }\n/******/ ])\n});\n\n\n\n/** WEBPACK FOOTER **\n ** cond.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap b5a0ffe402abe91a29f8\n **/","\"use strict\";\n\n/**\n * Signals a warning condition. By default, warnings do not trigger the\n * debugger, but they console.warn the condition.\n *\n * @param {string|*} condition - The condition to signal. If `condition` is a\n *                               string, it will be turned into a Warning and\n *                               that warning will be signaled.\n * @param {...Array} recoveries - Recoveries to make available. An invoked\n *                                recovery will replace the value of the\n *                                `warn()` call.\n *\n * @returns `undefined` or the value of the invoked recovery.\n */\nfunction warn(cond) {\n  arguments[0] = typeof cond === \"string\" ? new Warning(cond) : cond;\n  return signal.apply(this, arguments);\n}\n\nfunction Warning() {}\nWarning.prototype = new Error;\nWarning.prototype.constructor = Warning;\n\n/**\n * Signals a continuable error. This function is identical to `error()`, except\n * it makes a `\"continue\"` recovery available. Invoking this recovery will allow\n * execution to continue normally. The recovery can optionally be given a value\n * that `cerror()` will return.\n *\n * @param {string|*} condition - The condition to signal. If `condition` is a\n *                               string, it will be turned into an Error before\n *                               being signaled.\n * @param {...Array} recoveries - Recoveries to make available. An invoked\n *                                recovery will replace the value of the\n *                                `cerror()` call.\n *\n * @returns The value of the invoked recovery.\n */\nfunction cerror() {\n  return error.apply(this, [\n    arguments[0],\n    [\"continue\",\n     \"Return undefined (or a value) and continue normally\",\n     function(x){return x;}]\n  ].concat([].slice.call(arguments, 1)));\n}\n\n/**\n * Signals an error. Optionally accepts one or more recoveries, which may\n * replace the value of the `error()` call.\n *\n * @param {string|*} condition - The condition to signal. If `condition` is a\n *                               string, it will be turned into an Error before\n *                               being signaled.\n * @param {...Array} recoveries - Recoveries to make available. An invoked\n *                                recovery will replace the value of the\n *                                `error()` call.\n *\n * @returns The value of the invoked recovery.\n *\n * @example\n * cond.error(\"Kaboom\");\n * cond.error(\"Something exploded\",\n *            [\"gimme-5\", \"Just returns 5\", function() { return 5; }]);\n * cond.error(new CustomError(\"Goodbye\"));\n */\nfunction error(cond) {\n  arguments[0] = typeof cond === \"string\" ? new Error(cond) : cond;\n  return signal.apply(this, arguments);\n}\n\n/**\n * Signals a condition. Optionally accepts one or more recoveries, which may\n * replace the value of the `signal()` call.\n *\n * @param {*} condition - The condition to signal.\n * @param {...Array} recoveries - Recoveries to make available. An invoked\n *                                recovery will replace the value of the\n *                                `signal()` call.\n *\n * @returns The value of the invoked recovery.\n *\n * @example\n * cond.signal(new InvalidEntry(entry));\n * cond.signal(new NotANumberError(num),\n *            [\"gimme-5\", \"Just returns 5\", function() { return 5; }]);\n */\nfunction signal(cond) {\n  if (arguments.length <= 1) {\n    return _signal(cond);\n  } else {\n    return recoverable.apply(\n      this,\n      [function(){return _signal(cond);}].concat([].slice.call(arguments, 1)));\n  }\n}\n\nfunction _signal(cond) {\n  var oldClusters = HANDLER_CLUSTERS;\n  try {\n    HANDLER_CLUSTERS.forEach(function(cluster) {\n      HANDLER_CLUSTERS = HANDLER_CLUSTERS.slice(1);\n      _signalCluster(cond, cluster);\n    });\n  } finally {\n    HANDLER_CLUSTERS = oldClusters;\n  }\n}\n\nfunction _signalCluster(cond, cluster) {\n  cluster.forEach(function(handlerEntry) {\n    if (typeof handlerEntry === \"function\") {\n      handlerEntry(cond);\n    } else if (typeof cond === \"object\" &&\n               cond instanceof handlerEntry[0]) {\n      handlerEntry[1](cond);\n    }\n  });\n}\n\n/**\n * Executes `handledBody` in a dynamic context with a set of given handlers\n * installed. Handlers can either be arrays of `[Constructor, handler]`, or\n * simply a lone function. In the array form, the handler will be called\n * whenever a condition is signaled which is `instanceof` that `Constructor`. In\n * the cases of a solo function handler, the handler will be unconditionally\n * executed.\n *\n * Note that handlerBind handlers do not automatically catch signals. In order\n * to handle/catch a signal, the handler callback must perform its own non-local\n * exit from the execution context. To automatically catch when a handler\n * matches, use `handlerCase()` instead.\n *\n * @param {Function} handledBody - Function to execute in a handled dynamic\n *                                 context.\n * @param {...Array|Function} handlers - Handlers to execute on matching\n *                                       signals. Executed first to last.\n *\n * @returns The value of `handledBody`.\n *\n * @example\n * cond.handlerBind(function() {\n *   cond.error(\"fail\");\n * }, [Error, console.error],\n *    [Error, function() { console.log(\"This one, too\"); }]);\n */\nfunction handlerBind(handledBody) {\n  var handlers = [].slice.call(arguments, 1),\n      oldInHandler = IN_HANDLER_SCOPE,\n      oldClusters = HANDLER_CLUSTERS;\n  try {\n    HANDLER_CLUSTERS = [handlers].concat(HANDLER_CLUSTERS);\n    IN_HANDLER_SCOPE = true;\n    return handledBody.call(this);\n  } catch(e) {\n    if (!(e instanceof Sentinel)) {\n      _signalCluster(e, handlers);\n    } else if (e instanceof Sentinel && e.fromDebug && !oldInHandler) {\n      throw e.condition;\n    }\n    throw e;\n  } finally {\n    HANDLER_CLUSTERS = oldClusters;\n    IN_HANDLER_SCOPE = oldInHandler;\n  }\n}\n\n/**\n * Executes `handledBody` in a dynamic execution context with a set of handlers\n * installed. Handlers passed to `handlerCase` will automatically catch/handle\n * signals, unlike `handlerBind`.\n *\n * @param {Function} handledBody - Function to execute in a handled dynamic\n *                                 context.\n * @param {...Array|Function} handlers - Handlers to execute on matching\n *                                       signals. Checked first to last.\n *\n * @returns The value of `handledBody`, or the value of a successful handler.\n *\n * @example\n * cond.handlerCase(function() {\n *   cond.error(\"fail\");\n * }, [Error, console.error],\n *    [Error, function() { console.log(\"This one won't be called\"); }]);\n */\nfunction handlerCase(handledBody) {\n  var sentinel = new Sentinel(),\n      handlers = [].slice.call(arguments, 1).map(function(handlerEntry) {\n        var isArrayEntry = Array.isArray(handlerEntry),\n            oldCallback = isArrayEntry ? handlerEntry[1] : handlerEntry;\n        if (isArrayEntry) {\n          return [handlerEntry[0], handlerCallback];\n        } else {\n          return handlerCallback;\n        }\n        function handlerCallback(e) {\n          sentinel.handler = oldCallback;\n          sentinel.error = e;\n          throw sentinel;\n        };\n      });\n  try {\n    return handlerBind.apply(this, [handledBody].concat(handlers));\n  } catch (e) {\n    if (e === sentinel) {\n      return sentinel.handler.call(this, sentinel.error);\n    } else {\n      throw e;\n    }\n  }\n}\n\nfunction listRecoveries() {\n  // \"Deep enough\" copy to protect the internal RECOVERIES array structure from\n  // user shenanigans.\n  return RECOVERIES.map(function(x) {\n    return x.map(function(x) { return x; });\n  });\n}\n\n/**\n * Executes `recoverableBody` as a recoverable block. Specified recoveries are\n * able to execute in the context of the `recoverable()` call, and any value\n * they return will be used to replace the value of the `recoverabl()` call.\n *\n * Usually, this feature is used by calling the `signal` family of\n * functions. `recoverable()` is mostly useful when wrapping non-`cond` code to\n * allow calls at your application level to be recoverable.\n *\n * @param {Function} recoverableBody - Function to execute.\n * @param {...Array} recoveries - Zero or more recoveries to be made available.\n *\n * @returns Either the return value of `recoverableBody`, if it succeeds, or the\n *          value returned by any invoked `recoveries` if it signals.\n *\n * @example\n * function someLibraryFunction() {\n *   throw new Error(\"I've never heard of CondJS\");\n * }\n *\n * cond.recoverable(function() {\n *   return someLibraryFunction();\n * }, [\"gimme-5\", \"Return 5\", function() { return 5; }]);\n */\nfunction recoverable(recoverableBody) {\n  var sentinel = new Sentinel(),\n      oldRecoveries = RECOVERIES,\n      recoveries = [].slice.call(arguments, 1).map(function(entry) {\n        var name = entry[0],\n            description = typeof entry[1] === \"string\" ? entry[1] : \"\",\n            callback = description ? entry[2] : entry[1];\n        return [name, description, function() {\n          sentinel.callback = callback;\n          sentinel.args = arguments;\n          throw sentinel;\n        }];\n      });\n  try {\n    RECOVERIES = recoveries.concat(RECOVERIES);\n    try {\n      return recoverableBody.call(this);\n    } catch(e) {\n      if (!(e instanceof Sentinel)) {\n        return _signal(e);\n      } else {\n        throw e;\n      }\n    }\n  } catch(e) {\n    if (e === sentinel) {\n      return sentinel.callback.apply(this, sentinel.args);\n    } else {\n      throw e;\n    }\n  } finally {\n    RECOVERIES = oldRecoveries;\n  }\n}\n\n/**\n * Used within a handler, will invoke a recovery by index, name, or even\n * directly if it was returned by `findRecovery()`\n *\n * @param {number|string|Array} - The recovery to invoke.\n *\n * @returns Nothing of value\n *\n * @example\n * cond.handlerBind(function() {\n *   return cerror(\"I'm making 'continue' available!\");\n * }, [Error, function(e) { cond.recover(\"continue\"); }]);\n */\nfunction recover(name) {\n  return _recover.apply(this, arguments);\n}\n\nfunction _recover(name) {\n  var recovery = Array.isArray(name) ? name : findRecovery(name),\n      recoveryArgs = [].slice.call(arguments, 1),\n      oldThis = this;\n  if (recovery) {\n    return recovery[recovery.length-1].apply(this, recoveryArgs);\n  } else {\n    return error(\"Recovery not found: \"+name, [\n      \"try-again\", \"Call recover() again with a new name\", function(x) {\n        return recover.apply(oldThis, recoveryArgs);\n      }\n    ]);\n\n  }\n}\n\n/**\n * Finds a recovery in the current dynamic context by name or index. The return\n * value of this function can be passed to `recover()` directly. No assumptions\n * should be made about the actual structure of the returned object, except that\n * `undefined` means no such recovery was found.\n *\n * @param {number|string} name - The name or index of the recovery.\n *\n * @returns {Array|undefined} recovery - The recovery found, or `undefined`.\n */\nfunction findRecovery(name) {\n  if (typeof name === \"string\") {\n    for (var i = 0; i < RECOVERIES.length; i++) {\n      if (name === RECOVERIES[i][0]) {\n        return RECOVERIES[i];\n      }\n    }\n    return undefined;\n  } else {\n    return RECOVERIES[name];\n  }\n}\n\n/**\n * Invokes the configured debugger.\n */\nfunction debug(condition) {\n  /*****************************************************************/\n  /* Welcome to the */ debugger; /* Read below for instructions!!! */\n  /*                                                               */\n  /* Recoveries may be available.                                  */\n  /* Call showRecoveries() in the JS console to list them.         */\n  /*                                                               */\n  /* If you pick a recovery, it will be invoked after you unpause  */\n  /* the debugger. Otherwise, `condition` will be thrown.          */\n  /*                                                               */\n  /*                Thanks for using CondJS!                       */\n  /*                                                               */\n  /*****************************************************************/\n\n  var __chosenRecovery,\n      __recoveryArgs;\n  function recover(name) {\n    var recovery = findRecovery(name);\n    if (recovery) {\n      __chosenRecovery = RECOVERIES.indexOf(recovery);\n      __recoveryArgs = arguments;\n      console.log(\"Selected recovery: [\"+__chosenRecovery+\"] \"+recovery[0]);\n      console.log(\"Unpause the debugger to continue.\");\n    } else {\n      console.log(\"Invalid recovery: \", name);\n      console.log(\"Use showRecoveries() to see a list of available recoveries\");\n    }\n  }\n  function showRecoveries() {\n    console.log(\n      (((condition && condition.toString) ? condition.toString() + \"\\n\": \"\") +\n       \"Available recoveries: \\n\" +\n       \"\\n\" +\n       RECOVERIES.reduce(function(acc, entry, i) {\n         return acc + formatRecovery(entry, i) + \"\\n\";\n       }, \"\") + \"\\n\" +\n       \"To use a recovery: `recover(<name or index>[, arg1[, arg2 ...]])`\\n\"+\n       \"\\n\" +\n       \"Unpause your debugger to continue.\" +\n       \"\"));\n  }\n\n  if (__chosenRecovery != null) {\n    _recover.apply(this, __recoveryArgs);\n  } else if (IN_HANDLER_SCOPE) {\n    var sentinel = new Sentinel();\n    sentinel.condition = condition;\n    sentinel.fromDebug = true;\n    throw sentinel;\n  } else {\n    throw condition;\n  }\n}\n\nfunction formatRecovery(entry, i) {\n  var name = entry[0],\n      description = (typeof entry[1] === \"string\" && entry[1].length) ?\n        \": \"+entry[1] :\n        \"\";\n  return \"[\"+i+\"] \"+entry[0]+description;\n}\n\n/*\n * Internals\n */\nfunction Sentinel() {}\n\nvar HANDLER_CLUSTERS = [[\n  [Warning, function(w) { console.warn(w); }],\n  // If we get anything else unhandled, force falling back into the debugger.\n  // Unless it's a warning, which we treat special.\n  function(c) {if (c instanceof Warning) { return; } else { debug(c); }}\n]],\n    RECOVERIES = [],\n    IN_HANDLER_SCOPE;\n\n\nmodule.exports = {\n  signal: signal,\n  error: error,\n  cerror: cerror,\n  warn: warn,\n  Warning: Warning,\n  handlerBind: handlerBind,\n  handlerCase: handlerCase,\n  recoverable: recoverable,\n  recover: recover,\n  findRecovery: findRecovery,\n  debug: debug\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/index.js\n ** module id = 0\n ** module chunks = 0\n **/"],"sourceRoot":""}