{"version":3,"sources":["webpack/universalModuleDefinition","webpack/bootstrap d8a8f06b02b7e11ee0b9","./src/index.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;;ACTA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uBAAa;AACb;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA,wC;;;;;;;ACvCA;;AAEA;AACA;AACA;AACA;AACA,YAAW,SAAS;AACpB;AACA;AACA,YAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,SAAS;AACpB;AACA;AACA,YAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB,UAAU;AAC3B;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,SAAS;AACpB;AACA;AACA,YAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAwD,UAAU,EAAE;AACpE;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,EAAE;AACb,YAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAwD,UAAU,EAAE;AACpE;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,mBAAkB,sBAAsB;AACxC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,SAAS;AACpB;AACA,YAAW,kBAAkB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ,2BAA0B,8BAA8B,EAAE;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAW,SAAS;AACpB;AACA,YAAW,kBAAkB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ,2BAA0B,yCAAyC,EAAE;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,IAAG;AACH;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,+BAA8B,UAAU,EAAE;AAC1C,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,SAAS;AACpB,YAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI,sCAAsC,UAAU,EAAE;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,QAAO;AACP;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,MAAK;AACL;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,oBAAoB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,KAAI,uBAAuB,0BAA0B,EAAE;AACvD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,cAAc;AACzB;AACA,cAAa,gBAAgB;AAC7B;AACA;AACA;AACA,oBAAmB,uBAAuB;AAC1C;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAQ;AACR;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,0BAAyB,iBAAiB,EAAE;AAC5C;AACA;AACA,gBAAe,2BAA2B,QAAQ,EAAE,OAAO,UAAU;AACrE;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"cond\"] = factory();\n\telse\n\t\troot[\"cond\"] = factory();\n})(this, function() {\nreturn ","\n// The module cache\nvar installedModules = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tif(installedModules[moduleId])\n\t\treturn installedModules[moduleId].exports;\n\t\n\t// Create a new module (and put it into the cache)\n\tvar module = installedModules[moduleId] = {\n\t\texports: {},\n\t\tid: moduleId,\n\t\tloaded: false\n\t};\n\t\n\t// Execute the module function\n\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\t\n\t// Flag the module as loaded\n\tmodule.loaded = true;\n\t\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = modules;\n\n// expose the module cache\n__webpack_require__.c = installedModules;\n\n// __webpack_public_path__\n__webpack_require__.p = \"\";\n\n\n// Load entry module and return exports\nreturn __webpack_require__(0);","\"use strict\";\n\n/**\n * Signals a warning condition. By default, warnings do not trigger the\n * debugger, but they console.warn the condition.\n *\n * @param {string|*} condition - The condition to signal. If `condition` is a\n *                               string, it will be turned into a Warning and\n *                               that warning will be signaled.\n * @param {...Array} recoveries - Recoveries to make available. An invoked\n *                                recovery will replace the value of the\n *                                `warn()` call.\n *\n * @returns `undefined` or the value of the invoked recovery.\n */\nfunction warn(cond) {\n  arguments[0] = typeof cond === \"string\" ? new Warning(cond) : cond;\n  return signal.apply(this, arguments);\n}\n\nfunction Warning() {}\nWarning.prototype = new Error;\nWarning.prototype.constructor = Warning;\n\n/**\n * Signals a continuable error. This function is identical to `error()`, except\n * it makes a `\"continue\"` recovery available. Invoking this recovery will allow\n * execution to continue normally. The recovery can optionally be given a value\n * that `cerror()` will return.\n *\n * @param {string|*} condition - The condition to signal. If `condition` is a\n *                               string, it will be turned into an Error before\n *                               being signaled.\n * @param {...Array} recoveries - Recoveries to make available. An invoked\n *                                recovery will replace the value of the\n *                                `cerror()` call.\n *\n * @returns The value of the invoked recovery.\n */\nfunction cerror() {\n  return error.apply(this, [\n    arguments[0],\n    [\"continue\",\n     \"Return undefined (or a value) and continue normally\",\n     function(x){return x;}]\n  ].concat([].slice.call(arguments, 1)));\n}\n\n/**\n * Signals an error. Optionally accepts one or more recoveries, which may\n * replace the value of the `error()` call.\n *\n * @param {string|*} condition - The condition to signal. If `condition` is a\n *                               string, it will be turned into an Error before\n *                               being signaled.\n * @param {...Array} recoveries - Recoveries to make available. An invoked\n *                                recovery will replace the value of the\n *                                `error()` call.\n *\n * @returns The value of the invoked recovery.\n *\n * @example\n * cond.error(\"Kaboom\");\n * cond.error(\"Something exploded\",\n *            [\"gimme-5\", \"Just returns 5\", function() { return 5; }]);\n * cond.error(new CustomError(\"Goodbye\"));\n */\nfunction error(cond) {\n  arguments[0] = typeof cond === \"string\" ? new Error(cond) : cond;\n  return signal.apply(this, arguments);\n}\n\n/**\n * Signals a condition. Optionally accepts one or more recoveries, which may\n * replace the value of the `signal()` call.\n *\n * @param {*} condition - The condition to signal.\n * @param {...Array} recoveries - Recoveries to make available. An invoked\n *                                recovery will replace the value of the\n *                                `signal()` call.\n *\n * @returns The value of the invoked recovery.\n *\n * @example\n * cond.signal(new InvalidEntry(entry));\n * cond.signal(new NotANumberError(num),\n *            [\"gimme-5\", \"Just returns 5\", function() { return 5; }]);\n */\nfunction signal(cond) {\n  if (arguments.length <= 1) {\n    return _signal(cond);\n  } else {\n    return recoverable.apply(\n      this,\n      [function(){return _signal(cond);}].concat([].slice.call(arguments, 1)));\n  }\n}\n\nfunction _signal(cond) {\n  var oldClusters = HANDLER_CLUSTERS;\n  try {\n    HANDLER_CLUSTERS.forEach(function(cluster) {\n      HANDLER_CLUSTERS = HANDLER_CLUSTERS.slice(1);\n      _signalCluster(cond, cluster);\n    });\n  } finally {\n    HANDLER_CLUSTERS = oldClusters;\n  }\n}\n\nfunction _signalCluster(cond, cluster) {\n  cluster.forEach(function(handlerEntry) {\n    if (typeof handlerEntry === \"function\") {\n      handlerEntry(cond);\n    } else if (typeof cond === \"object\" &&\n               cond instanceof handlerEntry[0]) {\n      handlerEntry[1](cond);\n    }\n  });\n}\n\n/**\n * Executes `handledBody` in a dynamic context with a set of given handlers\n * installed. Handlers can either be arrays of `[Constructor, handler]`, or\n * simply a lone function. In the array form, the handler will be called\n * whenever a condition is signaled which is `instanceof` that `Constructor`. In\n * the cases of a solo function handler, the handler will be unconditionally\n * executed.\n *\n * Note that handlerBind handlers do not automatically catch signals. In order\n * to handle/catch a signal, the handler callback must perform its own non-local\n * exit from the execution context. To automatically catch when a handler\n * matches, use `handlerCase()` instead.\n *\n * @param {Function} handledBody - Function to execute in a handled dynamic\n *                                 context.\n * @param {...Array|Function} handlers - Handlers to execute on matching\n *                                       signals. Executed first to last.\n *\n * @returns The value of `handledBody`.\n *\n * @example\n * cond.handlerBind(function() {\n *   cond.error(\"fail\");\n * }, [Error, console.error],\n *    [Error, function() { console.log(\"This one, too\"); }]);\n */\nfunction handlerBind(handledBody) {\n  var handlers = [].slice.call(arguments, 1),\n      oldInHandler = IN_HANDLER_SCOPE,\n      oldClusters = HANDLER_CLUSTERS;\n  try {\n    HANDLER_CLUSTERS = [handlers].concat(HANDLER_CLUSTERS);\n    IN_HANDLER_SCOPE = true;\n    return handledBody.call(this);\n  } catch(e) {\n    if (!(e instanceof Sentinel)) {\n      _signalCluster(e, handlers);\n    } else if (e instanceof Sentinel && e.fromDebug && !oldInHandler) {\n      throw e.condition;\n    }\n    throw e;\n  } finally {\n    HANDLER_CLUSTERS = oldClusters;\n    IN_HANDLER_SCOPE = oldInHandler;\n  }\n}\n\n/**\n * Executes `handledBody` in a dynamic execution context with a set of handlers\n * installed. Handlers passed to `handlerCase` will automatically catch/handle\n * signals, unlike `handlerBind`.\n *\n * @param {Function} handledBody - Function to execute in a handled dynamic\n *                                 context.\n * @param {...Array|Function} handlers - Handlers to execute on matching\n *                                       signals. Checked first to last.\n *\n * @returns The value of `handledBody`, or the value of a successful handler.\n *\n * @example\n * cond.handlerCase(function() {\n *   cond.error(\"fail\");\n * }, [Error, console.error],\n *    [Error, function() { console.log(\"This one won't be called\"); }]);\n */\nfunction handlerCase(handledBody) {\n  var sentinel = new Sentinel(),\n      handlers = [].slice.call(arguments, 1).map(function(handlerEntry) {\n        var isArrayEntry = Array.isArray(handlerEntry),\n            oldCallback = isArrayEntry ? handlerEntry[1] : handlerEntry;\n        if (isArrayEntry) {\n          return [handlerEntry[0], handlerCallback];\n        } else {\n          return handlerCallback;\n        }\n        function handlerCallback(e) {\n          sentinel.handler = oldCallback;\n          sentinel.error = e;\n          throw sentinel;\n        };\n      });\n  try {\n    return handlerBind.apply(this, [handledBody].concat(handlers));\n  } catch (e) {\n    if (e === sentinel) {\n      return sentinel.handler.call(this, sentinel.error);\n    } else {\n      throw e;\n    }\n  }\n}\n\nfunction listRecoveries() {\n  // \"Deep enough\" copy to protect the internal RECOVERIES array structure from\n  // user shenanigans.\n  return RECOVERIES.map(function(x) {\n    return x.map(function(x) { return x; });\n  });\n}\n\n/**\n * Executes `recoverableBody` as a recoverable block. Specified recoveries are\n * able to execute in the context of the `recoverable()` call, and any value\n * they return will be used to replace the value of the `recoverabl()` call.\n *\n * Usually, this feature is used by calling the `signal` family of\n * functions. `recoverable()` is mostly useful when wrapping non-`cond` code to\n * allow calls at your application level to be recoverable.\n *\n * @param {Function} recoverableBody - Function to execute.\n * @param {...Array} recoveries - Zero or more recoveries to be made available.\n *\n * @returns Either the return value of `recoverableBody`, if it succeeds, or the\n *          value returned by any invoked `recoveries` if it signals.\n *\n * @example\n * function someLibraryFunction() {\n *   throw new Error(\"I've never heard of CondJS\");\n * }\n *\n * cond.recoverable(function() {\n *   return someLibraryFunction();\n * }, [\"gimme-5\", \"Return 5\", function() { return 5; }]);\n */\nfunction recoverable(recoverableBody) {\n  var sentinel = new Sentinel(),\n      oldRecoveries = RECOVERIES,\n      recoveries = [].slice.call(arguments, 1).map(function(entry) {\n        var name = entry[0],\n            description = typeof entry[1] === \"string\" ? entry[1] : \"\",\n            callback = description ? entry[2] : entry[1];\n        return [name, description, function() {\n          sentinel.callback = callback;\n          sentinel.args = arguments;\n          throw sentinel;\n        }];\n      });\n  try {\n    RECOVERIES = recoveries.concat(RECOVERIES);\n    return recoverableBody.call(this);\n  } catch(e) {\n    if (e === sentinel) {\n      return sentinel.callback.apply(this, sentinel.args);\n    } else {\n      throw e;\n    }\n  } finally {\n    RECOVERIES = oldRecoveries;\n  }\n}\n\n/**\n * Used within a handler, will invoke a recovery by index, name, or even\n * directly if it was returned by `findRecovery()`\n *\n * @param {number|string|Array} - The recovery to invoke.\n *\n * @returns Nothing of value\n *\n * @example\n * cond.handlerBind(function() {\n *   return cerror(\"I'm making 'continue' available!\");\n * }, [Error, function(e) { cond.recover(\"continue\"); }]);\n */\nfunction recover(name) {\n  return _recover.apply(this, arguments);\n}\n\nfunction _recover(name) {\n  var recovery = Array.isArray(name) ? name : findRecovery(name),\n      recoveryArgs = [].slice.call(arguments, 1),\n      oldThis = this;\n  if (recovery) {\n    return recovery[recovery.length-1].apply(this, recoveryArgs);\n  } else {\n    return error(\"Recovery not found: \"+name, [\n      \"try-again\", \"Call recover() again with a new name\", function(x) {\n        return recover.apply(oldThis, recoveryArgs);\n      }\n    ]);\n\n  }\n}\n\n/**\n * Finds a recovery in the current dynamic context by name or index. The return\n * value of this function can be passed to `recover()` directly. No assumptions\n * should be made about the actual structure of the returned object, except that\n * `undefined` means no such recovery was found.\n *\n * @param {number|string} name - The name or index of the recovery.\n *\n * @returns {Array|undefined} recovery - The recovery found, or `undefined`.\n */\nfunction findRecovery(name) {\n  if (typeof name === \"string\") {\n    for (var i = 0; i < RECOVERIES.length; i++) {\n      if (name === RECOVERIES[i][0]) {\n        return RECOVERIES[i];\n      }\n    }\n    return undefined;\n  } else {\n    return RECOVERIES[name];\n  }\n}\n\n/**\n * Invokes the configured debugger.\n */\nfunction debug(condition) {\n  /*****************************************************************/\n  /* Welcome to the */ debugger; /* Read below for instructions!!! */\n  /*                                                               */\n  /* Recoveries may be available.                                  */\n  /* Call showRecoveries() in the JS console to list them.         */\n  /*                                                               */\n  /* If you pick a recovery, it will be invoked after you unpause  */\n  /* the debugger. Otherwise, `condition` will be thrown.          */\n  /*                                                               */\n  /*                Thanks for using CondJS!                       */\n  /*                                                               */\n  /*****************************************************************/\n\n  var __chosenRecovery,\n      __recoveryArgs;\n  function recover(name) {\n    var recovery = findRecovery(name);\n    if (recovery) {\n      __chosenRecovery = RECOVERIES.indexOf(recovery);\n      __recoveryArgs = arguments;\n      console.log(\"Selected recovery: [\"+__chosenRecovery+\"] \"+recovery[0]);\n      console.log(\"Unpause the debugger to continue.\");\n    } else {\n      console.log(\"Invalid recovery: \", name);\n      console.log(\"Use showRecoveries() to see a list of available recoveries\");\n    }\n  }\n  function showRecoveries() {\n    console.log(\n      (((condition && condition.toString) ? condition.toString() + \"\\n\": \"\") +\n       \"Available recoveries: \\n\" +\n       \"\\n\" +\n       RECOVERIES.reduce(function(acc, entry, i) {\n         return acc + formatRecovery(entry, i) + \"\\n\";\n       }, \"\") + \"\\n\" +\n       \"To use a recovery: `recover(<name or index>[, arg1[, arg2 ...]])`\\n\"+\n       \"\\n\" +\n       \"Unpause your debugger to continue.\" +\n       \"\"));\n  }\n\n  if (__chosenRecovery != null) {\n    _recover.apply(this, __recoveryArgs);\n  } else if (IN_HANDLER_SCOPE) {\n    var sentinel = new Sentinel();\n    sentinel.condition = condition;\n    sentinel.fromDebug = true;\n    throw sentinel;\n  } else {\n    throw condition;\n  }\n}\n\nfunction formatRecovery(entry, i) {\n  var name = entry[0],\n      description = (typeof entry[1] === \"string\" && entry[1].length) ?\n        \": \"+entry[1] :\n        \"\";\n  return \"[\"+i+\"] \"+entry[0]+description;\n}\n\n/*\n * Internals\n */\nfunction Sentinel() {}\n\nvar HANDLER_CLUSTERS = [[\n  [Warning, function(w) { console.warn(w); }],\n  // If we get anything else unhandled, force falling back into the debugger.\n  // Unless it's a warning, which we treat special.\n  function(c) {if (c instanceof Warning) { return; } else { debug(c); }}\n]],\n    RECOVERIES = [],\n    IN_HANDLER_SCOPE;\n\n\nmodule.exports = {\n  signal: signal,\n  error: error,\n  cerror: cerror,\n  warn: warn,\n  Warning: Warning,\n  handlerBind: handlerBind,\n  handlerCase: handlerCase,\n  recoverable: recoverable,\n  recover: recover,\n  findRecovery: findRecovery,\n  debug: debug\n};\n"],"sourceRoot":"webpack-module://"}